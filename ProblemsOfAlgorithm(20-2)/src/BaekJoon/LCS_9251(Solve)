LCS_9251(Solve)

DP로 접근한다.

CAPCAK와 ACAYKP가 있다고 할 때, 접근법은 다음과 같다.

	0 A C A Y K P
0	0 0 0 0 0 0 0
C	0       *
A	0
P	0
C	0
A	0
K	0

우선, 2차원 배열을 다음과 같이 채운다. 0은 문자가 없다는 것을 의미한다.
이 때, [C, Y] = *는, ACAY와 C의 LCS 길이를 의미한다.
이를 한 행씩 채워나간다.

1. C행: C와 A, AC, ACA, ACAY...의  LCS 길이 값
	0 A C A Y K P
0	0 0 0 0 0 0 0
C	0 0 1 1 1 1 1
A	0
P	0
C	0
A	0
K	0

2. A행: CA와 A, AC, ACA, ACAY...의  LCS 길이 값
	0 A C A Y K P
0	0 0 0 0 0 0 0
C	0 0 1 1 1 1 1
A	0 1 1 2 2 2 2
P	0
C	0
A	0
K	0

3. P행: CAP와 A, AC, ACA, ACAY...의  LCS 길이 값
	0 A C A Y K P
0	0 0 0 0 0 0 0
C	0 0 1 1 1 1 1
A	0 1 1 2 2 2 2
P	0 1 1 2 2 2 3
C	0
A	0
K	0

즉, 위 과정을 볼 때 현재 행의 값과 같은 문자를 만나면 +1이 되는 셈이다.
단 +1을 고려하는 위치는?
	ACAYKP와 CAP의 경우, P가 동일함을 알 수있다.
	서로의 끝 문자가 동일하므로, 바로 이전의 값은 ACAYK와 CA가 될 것이다. 즉, 왼쪽 대각선 위 값이다.

문자가 다를 경우에는  두가지 경우를 고려한다.
예를 들어, CAP와 ACAY를 고려할 경우에
	1) P와 Y는 서로 다른 문자이다.
	2) CA, ACAY를 고려한 값과 CAP, ACA를 고려한 값 중 우수한 값을 고르면 될 것이다.
	
이를 점화식으로 표현하면 다음과 같다.

if 끝 문자가 같다면
	dp[i][j] = dp[i-1][j-1] + 1;
else
	dp[i][j] = max( dp[i-1][j], dp[i][j-1] );
	
추가 정보)
LCS의 실제 문자열을 얻어내려면 어떻게해야 하는가? 행 기준으로 값이 변하는 위치는 찾으면 된다.
단, 행과 열은 겹쳐서는 안된다.

	0 A C A Y K P
0	0 0 0 0 0 0 0
C	0 0 1 1 1 1 1
A	0 1 1 2 2 2 2
P	0 1 1 2 2 2 3
C	0 1 2 2 2 2 3
A	0 1 2 3 3 3 3 
K	0 1 2 3 3 4 4 

가장 끝자리부터 시작하여 자신과 같은 숫자가 있는곳까지 따라간다.
그리고 왼쪽, 위쪽 둘중 둘다 같은 수가 없다면, 대각선 방향 값이 현재 값 - 1인지 확인해보고 그 수를 따라간다.
이것을 테이블에서 0이 나타날 때 까지 계속해서 반복한다.


