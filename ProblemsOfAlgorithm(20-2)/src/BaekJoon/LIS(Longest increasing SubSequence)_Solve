LIS(Longest increasing SubSequence)

{10, 20, 40, 25, 20, 50, 30, 70, 85}가 배열에 저장되었다고 할 때,
10 - 20 - 40 - 50 - 70 - 85와 같이 증가하는 부분 수열의 길이를 찾는 문제이다.
(index i < j일 때 arr[i] < arr[j]인 최대 길이 부분 수열을 찾는 것)

1. Dynamic Programming으로 이중 Loop를 이용하여 구현한다면?
어떤 특정한 위치 i에서, dp[i] = i번째 값을 마지막 값으로 가질 때 최대 증가 수열 길이

dp[i]는
조건1. arr[i]가 arr[i의 이전 값]보다 크고
조건2. dp[i]가 dp[i의 이전 값] + 1보다 작을 때
dp[i] = dp[i의 이전 값] + 1로 업데이트한다.


1) 처음에는 아무것도 없으니 첫 값을 추가한다.
dp[1] = 1

2) 20을 기준으로 봤을 때: 가장 끝 값인 10보다 크니 추가한다.
i = 2를 기준으로, dp[2] = 1로 두고,
조건1. arr[2] = 20은 arr[1] = 10보다  크다.
조건2. dp[2] = 1이 dp[1] + 1 = 2보다 작다.
따라서 dp[2] = 2이다.

3) 40을 기준으로 봤을 때: 가장 끝 값인 40보다 크니 추가한다.
i = 3을 기준으로 dp[3] = 1로 두고,
1번 인덱스 기준)
조건1. arr[1] = 10은 arr[3] = 40보다  작다. 즉 1 - 40의 형태가 가능하다.
조건2. dp[3] = 1이 dp[1] + 1 = 2보다 작다. 즉 1 - 40 형태가 가능하다.
dp[3] = 2이다.

2번 인덱스 기준)
조건1. arr[2] = 20은 arr[3] = 40보다 작다. 20 - 40의 형태가 가능하다.
조건2. dp[3] = 2가 dp[2] + 1 = 3보다 작다. 즉 1 - 20 - 40의 형태가 가능하다.
dp[3] = 3이다.


4) 25를 기준으로 봤을 때: 
i = 4을 기준으로 dp[4] = 1로 두고,
1번 인덱스 기준)
조건1. arr[1] = 10은 arr[4] = 25보다  작다. 즉 1 - 25의 형태가 가능하다.
조건2. dp[4] = 1이 dp[1] + 1 = 2보다 작다. 즉 1 - 25 형태가 가능하다.
dp[4] = 2이다.

2번 인덱스 기준)
조건1. arr[2] = 20은 arr[4] = 25보다 작다. 20 - 25의 형태가 가능하다.
조건2. dp[4] = 2가 dp[2] + 1 = 3보다 작다. 즉 1 - 20 - 25의 형태가 가능하다.
dp[4] = 3이다.

3번 인덱스 기준)
조건1. arr[3] = 40은 arr[4] = 25보다 크다. 따라서 dp[3]과 이어질 수는 없다.
dp[4] = 3이다.

...

이와 같은 과정으로 이어나간다.





